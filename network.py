"""

Description:
Network is the class for the pathway-pathway interaction network.
Helper classes include Edge and Vertex.
InteractionNetwork represents a network with 2 edge types:
direct (DIR = +1) and inverse (INV = -1).

An example of how to use the InteractionNetwork to output a .csv network
(for visualization in Cytoscape) is provided in __main__.

Usage:
   python network.py test_network_file num_nodes output_file

(1) test_network_file: a pathway coverage .txt file from an ADAGE model
                       (generated by pathway_coverage.R)
(2) num_nodes: number of nodes in the model
(3) output_file: the name of the output network file

Output:
A file (-output_file-) is created with the network for the pathway data
from a specified ADAGE model.

"""

import sys
import itertools
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random

import utils

DIR = 1
INV = -1
# Usage: in `_pathway_node_shuffle`. Sets an upper bound for the
# number of times we can randomly assign a pathway to a node during the side-
# preserving ADAGE model permutation.
MAX_ITERS = 30000

# Usage: in `_cor_score_filter`. cor_score > GLOBAL_COR in the 1st output
# will represent globally inverse relationships in the pathway-pathway network.
# Additionally, cor_score <= GLOBAL_COR and padjust < COR_THRESH can
# represent inversely-related pathways in some circumstances.
GLOBAL_COR = 0.50
COR_THRESH_MAX = 0.10
COR_THRESH = [0.10, 0.05, 0.01, 0.005]


class Edge:

    def __init__(self, start, end, etype, adage_nodes=[]):
        self.etype = etype
        self.edge = (start, end)
        self.edge_id = (self.edge[0] * self.etype,
                        self.edge[1] * self.etype)
        self.weight = len(adage_nodes)
        self.adage_nodes = adage_nodes

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        else:
            return (self.etype == other.etype and
                    sorted(self.edge) == sorted(other.edge))

    def __ne__(self, other):
        return not self.__eq__(other)

    def get_adage_nodes(self):
        return self.adage_nodes
        
    def adage_nodes_to_string(self):
        return " ".join(map(str, self.adage_nodes))

    def connected_to(self, vid):
        """
        Note: if this is going to stay a public function, I need to add error
        handling for an input vid that isn't part of the edge.
        :param vid: vertex id
        :returns: the vertex that shares an edge with vid
        """
        if conn_to not in self.edge:
            return None
        conn_to = self.edge[1] if self.edge[0] == vid else self.edge[0]
        return conn_to


class Vertex:

    def __init__(self, vid):
        self._id = vid
        self.edges = {INV: {}, DIR: {}}

    def unweighted_degree(self, etype):
        return len(self.edges[etype])

    def all_first_neighbor_ids(self):
        """
        :returns: all first neighbors of a vertex, regardless of edge type.
        """
        neighbors = []
        for etype in self.edges.keys():
            neighbors += self.all_etype_first_neighbor_ids(etype)
        return list(set(neighbors))

    def all_etype_first_neighbor_ids(self, etype):
        """
        :returns: first neighbors with the specified edge type.
        """
        return self.edges[etype].keys()


class InteractionNetwork:

    def __init__(self, sig_pathways, num_nodes):
        self.vertices = {}  # vertex id (vid) -> vertex obj
        self.edges = {}  # (vid0, vid1) -> edge obj

        self.num_nodes = num_nodes
        self.nodes = {INV: set(), DIR: set()}
        self.etype_weights = {}

        self.num_pathways = 0
        self.pathways = {}  # pathway -> vid

        if isinstance(sig_pathways, str):
            self.sig_pathways_file = sig_pathways
            self.network_dict_direct = {}
            self.network_dict_inverse = {}
            self._construct_from_file()
        else:
            # Some analyses generate network data dynamically
            # and store it in data structures.
            self.sig_pathways_file = None
            # TODO: is this the functionality I want?
            self._construct_from_permutation(sig_pathways)
        
    def __getitem__(self, item_id):
        for pw, vid in self.pathways.iteritems():
            if item_id == vid:
                return pw
        return None

    def _construct_from_file(self):
        """ Builds the network using the significant pathways file.
        """
        node_pathway_df = utils.read_significant_pathways_file(self.sig_pathways_file)

        network_dict_direct = {}
        network_dict_inverse = {}

        ### identify DIR edges ###
        node_groupings_same_side = node_pathway_df.groupby(["node", "side"])
        for (node, _), group in node_groupings_same_side:
            assoc_pathways = group["pathway"].tolist()
            pairings = list(itertools.combinations(assoc_pathways, 2))
            if len(pairings) > 0:
                self.nodes[DIR].add(node)
            for pathway_pair in pairings:
                v0 = self.add_pathway(pathway_pair[0])
                v1 = self.add_pathway(pathway_pair[1])
                new_edge = self.edge_tuple(v0, v1)
                if new_edge not in network_dict_direct:
                    network_dict_direct[new_edge] = []
                network_dict_direct[new_edge].append(node)

        ### identify INV edges ###
        node_groupings_either_side = node_pathway_df.groupby(["node"])
        for node, group in node_groupings_either_side:
            divide_by_side = group.groupby(["side"])
            if len(divide_by_side) == 2:
                self.nodes[INV].add(node)
                diff_sides = []
                for side, subgroup in divide_by_side:
                    diff_sides.append(subgroup["pathway"].tolist())
                for pw0 in diff_sides[0]:
                    for pw1 in diff_sides[1]:
                        if pw0 != pw1:
                            v0 = self.add_pathway(pw0)
                            v1 = self.add_pathway(pw1)
                            new_edge = self.edge_tuple(v0, v1)
                            if new_edge not in network_dict_inverse:
                                network_dict_inverse[new_edge] = []
                            network_dict_inverse[new_edge].append(node)
        self._augment_network(network_dict_inverse, INV)
        self._augment_network(network_dict_direct, DIR)
        self._total_edge_type_weight()

    def _cor_score_filter(self, cor_file, output_prefix, dir=False):
        # TODO: pending code review.
        """ Ignore all direct relationships. Using constant GLOBAL_COR
            specified above, output the following:
              1. globally inverse pathway-pathway relationships
                (cor_score > GLOBAL_COR)
              2. a directory of potentially significant but
                 cor_score <= GLOBAL_COR relationships with a few different
                 padjust cutoffs COR_THRESH.
        """
        filtering_df = pd.read_table(cor_file,
                                     sep="\t",
                                     header=0,
                                     usecols=["node", "padjust", "cor_score"])

        filtering_df["node"] = filtering_df["node"].apply(
            lambda x: int(filter(str.isdigit, x)))
        filtering_df.set_index(["node"], inplace=True)

        global_rels = []  # 1.
        padj_sig_rels = {}  # 2.

        for cutoff in COR_THRESH:
            padj_sig_rels[cutoff] = []

        if dir:
            for (v0, v1), edge_obj in self.edges.iteritems():
                # filter to only consider inverse relationships.
                if edge_obj.etype == DIR:
                    pw_v0 = self.__getitem__(abs(v0))
                    pw_v1 = self.__getitem__(abs(v1))
                    global_weight = 0
                    global_nodes = []
                    padj_node_wts = []
                    for node in edge_obj.adage_nodes:
                        match_node = filtering_df.loc[node]
                        if not match_node.empty:
                            cor_score = match_node["cor_score"]
                            padj = match_node["padjust"]
                            if cor_score < 0.25:
                                global_weight += 1 - cor_score
                                global_nodes.append(node)
                            elif padj <= COR_THRESH_MAX:
                                node_wt_info = (cor_score, padj, node)
                                padj_node_wts.append(node_wt_info)
                    # update global_rels.
                    if global_nodes != []:
                        gedge_info = (pw_v0, pw_v1,
                                      global_weight, global_nodes, DIR)
                        global_rels.append(gedge_info)
                    else:
                        remain = padj_node_wts
                        for cutoff in COR_THRESH:
                            remain = [ei for ei in remain if ei[1] <= cutoff]
                            if remain != []:
                                wt = reduce(lambda acc,ei: acc+ei[0], remain, 0)
                                nodes = map(lambda ei: ei[2], remain)
                                pedge_info = (pw_v0, pw_v1,
                                              wt, nodes, DIR)
                                padj_sig_rels[cutoff].append(pedge_info)
                            else:
                                break
        else:
            for (v0, v1), edge_obj in self.edges.iteritems():
                # filter to only consider inverse relationships.
                if edge_obj.etype == INV:
                    pw_v0 = self.__getitem__(abs(v0))
                    pw_v1 = self.__getitem__(abs(v1))
                    global_weight = 0
                    global_nodes = []
                    padj_node_wts = []
                    for node in edge_obj.adage_nodes:
                        match_node = filtering_df.loc[node]
                        if not match_node.empty:
                            cor_score = match_node["cor_score"]
                            padj = match_node["padjust"]
                            if cor_score > GLOBAL_COR:
                                global_weight += cor_score
                                global_nodes.append(node)
                            elif padj <= COR_THRESH_MAX:
                                node_wt_info = (cor_score, padj, node)
                                padj_node_wts.append(node_wt_info)
                    # update global_rels.
                    if global_nodes != []:
                        gedge_info = (pw_v0, pw_v1,
                                      global_weight, global_nodes, INV)
                        global_rels.append(gedge_info)
                    else:
                        remain = padj_node_wts
                        for cutoff in COR_THRESH:
                            remain = [ei for ei in remain if ei[1] <= cutoff]
                            if remain != []:
                                wt = reduce(lambda acc,ei: acc+ei[0], remain, 0)
                                nodes = map(lambda ei: ei[2], remain)
                                pedge_info = (pw_v0, pw_v1,
                                              wt, nodes, INV)
                                padj_sig_rels[cutoff].append(pedge_info)
                            else:
                                break
        cols = ["PW1", "PW2", "Weight", "Nodes", "Type"]
        global_df = pd.DataFrame(global_rels, columns=cols)
        global_df = global_df.sort_values(by=["Weight"], ascending=False)
        global_df.to_csv(path_or_buf=output_prefix + "global",
                         sep="\t",
                         index=False)

        padj_dfs = {}
        for cutoff, clist in padj_sig_rels.iteritems():
            cutoff_df = pd.DataFrame(clist, columns=cols)
            cutoff_df = cutoff_df.sort_values(by=["Weight"], ascending=False)
            cutoff_df.to_csv(path_or_buf=output_prefix + "fdr=" + str(cutoff),
                             sep="\t",
                             index=False)

    def adage_model_permutation(self):
        """ Builds a permuted network from the significant pathways file.
        """
        node_pathway_df = utils.read_significant_pathways_file(self.sig_pathways_file)
        node_groupings = node_pathway_df.groupby(["side", "node"])

        pathway_nodes = {"pos": [], "neg": []}
        for (side, node), group in node_groupings:
            pathways = group["pathway"].tolist()
            for pathway in pathways:
                pathway_nodes[side].append((pathway, node))
                
        pos_shuffle = self._pathway_node_shuffle(pathway_nodes["pos"])
        while pos_shuffle is None:
            pos_shuffle = self._pathway_node_shuffle(pathway_nodes["pos"])

        neg_shuffle = self._pathway_node_shuffle(pathway_nodes["neg"])
        while neg_shuffle is None:
            neg_shuffle = self._pathway_node_shuffle(pathway_nodes["neg"])

        pos_correct = self._shuffle_correctness(pos_shuffle,
                                                pathway_nodes["pos"])
        neg_correct = self._shuffle_correctness(neg_shuffle,
                                                pathway_nodes["neg"])
        
        # TODO: assert or return None?
        assert pos_correct and neg_correct, "Node shuffle did not preserve the expected invariants."
        
        sig_pathways = {"pos": pos_shuffle, "neg": neg_shuffle}

        # TODO: Python referencing?

        # self-assignment
        self.permuted = InteractionNetwork(sig_pathways, self.num_nodes)
        self.permuted._total_edge_type_weight()

        # to return
        permutation = Network(sig_pathways, self.num_nodes)
        permutation._total_edge_type_weight()
        return permutation

    def divide(self):
        """ Specific to the ADAGE model permutation. Updates the
            network so that edge weights are based on the observed-to-expected
            ratio (original-to-permuted).
            Edges specific to the original network will maintain their edge
            weights, whereas those specific to the permuted network will be
            assigned their reciprocal weight.
        """
        for etype in self.nodes.keys():
            if len(self.nodes[etype]):
                self.nodes[etype] = set()
            self.etype_weights[etype] = (float(self.etype_weights[etype]) /
                                         float(self.permuted.etype_weights[etype]))
        mapping = self.aggregate_remap_pathways(self.permuted.pathways)
        for (v0, v1), edge in self.permuted.edges.iteritems():
            eid = self.remapped_edge(mapping, v0, v1)
            # TODO: review this. if edge in self.edges might work now
            # because of the __eq__
            if edge.edge_id in self.edges:
                if len(self.edges[edge_key].adage_nodes):
                    self.edges[edge_key].adage_nodes = []
                obs_to_exp = (float(self.edges[edge.edge_id].weight) /
                              float(edge.weight))
                self.edges[edge_key].weight = obs_to_exp
            else:
                edge_obj = Edge(eid[0], eid[1], edge.etype, [])
                edge_obj.weight = 1. / edge.weight
                self.edges[edge_key] = edge_obj
                self._add_edge_to_vertex(eid[0], edge_obj)
                self._add_edge_to_vertex(eid[1], edge_obj)

    def aggregate(self):
        """ This is the merge function to combine multiple networks.
        :param merge: the Network object being merged into the current network
        :returns: None
        """
        self.sig_pathways_file = None
        self.num_nodes += merge.num_nodes

        for etype in self.nodes.keys():
            # in an aggregate network, the nodes will differ for each model.
            if len(self.nodes[etype]) > 0:
                self.nodes[etype] = set()
            self.etype_weights[etype] += merge.etype_weights[etype]

        mapping = self.aggregate_remap_pathways(merge.pathways)
        for (v0, v1), edge in merge.edges.iteritems():
            eid = self.remapped_edge(mapping, v0, v1)
            edge_key = (eid[0] * edge.etype, eid[1] * edge.etype)
            if edge_key in self.edges:
                if len(self.edges[edge_key].adage_nodes) > 0:
                    self.edges[edge_key].adage_nodes = []
                self.edges[edge_key].weight += edge.weight
            else:
                edge_obj = Edge(eid[0], eid[1], edge.etype, [])
                edge_obj.weight = len(edge.adage_nodes)
                self.edges[edge_key] = edge_obj
                self._add_edge_to_vertex(eid[0], edge_obj)
                self._add_edge_to_vertex(eid[1], edge_obj)

    def aggregate_remap_pathways(self, pathway_mapping):
        """ The following tasks are carried out in the remapping:
        (1) If self.pathways contains the pathway to be merged, map the merge
            vid to self vid.
        (2) If not, create a vertex in self and then add the key-val pair
            accordingly.
        :param pathway_mapping: the (pathway -> vid) map for the network being
                                merged with self
        :returns: a (merge.vid -> self.vid) mapping for pathway id conversion
        """
        mapping = {}
        for pathway, vid in pathway_mapping.iteritems():
            if pathway in self.pathways:
                mapping[vid] = self.pathways[pathway]
            else:
                self_vid = self.add_pathway(pathway)
                self.vertices[self_vid] = Vertex(self_vid)
                mapping[vid] = self_vid
        return mapping

    def remapped_edge(self, remap, v0, v1):
        """ After aggregation, given an edge (v0, v1), return the corresponding
            edge name from the -remap- dictionary.
        """
        self_v0 = remap[abs(v0)]
        self_v1 = remap[abs(v1)]
        eid = self.edge_tuple(self_v0, self_v1)
        return eid

    def degree_distribution_plot(self, save_to=None):
        """ A degree distribution plot is created. Separate plots for each edge
            type, where the points are color-coded on the single output figure.
        :param save_to: specify the name of the .png the figure is saved to.
        :returns: None
        """
        n = len(self.vertices)
        nodes_with_degree = {INV: np.zeros(n), DIR: np.zeros(n)}
        for vertex in self.vertices.values():
            for etype in vertex.edges.keys():
                etype_degree = vertex.unweighted_degree(etype)
                nodes_with_degree[etype][etype_degree] += 1.0
        inverse_degree = nodes_with_degree[INV]/n
        direct_degree = nodes_with_degree[DIR]/n
        ymax = max(np.concatenate((inverse_degree, direct_degree))) + 0.05
        plt.ylim(0.0, ymax)
        plt.xlim(0, n + 1)
        plt.scatter(range(0, len(inverse_degree)), inverse_degree,
                    s=8, alpha=1.0, color="orange", marker="d")
        plt.scatter(range(0, len(direct_degree)), direct_degree,
                    s=8, alpha=1.0, color="purple")
        plt.xlabel("Degree k")
        plt.ylabel("Probability P(k)")
        if save_to is None:
            plt.show()
        else:
            plt.savefig(save_to)

    def edge_tuple(self, v0, v1):
        """ Enforce an edge invariant: start ID always < end ID.
        """
        edge = [v0, v1]
        edge.sort()
        return tuple(edge)

    def add_pathway(self, pathway):
        if pathway not in self.pathways:
            self.pathways[pathway] = self.num_pathways
            self.num_pathways += 1
        return self.pathways[pathway]

    def get_edge_weight(self, pw0, pw1, etype):
        v0 = self.pathways[pw0]
        v1 = self.pathways[pw1]
        eid = self.edge_tuple(v0, v1)
        if etype == INV:
            eid = (-eid[0], -eid[1])
        return self.edges[eid].weight

    def get_edge_pathways(self, edge_key):
        """ Return the pathways associated with an edge.
        """
        v0 = abs(edge_key[0])
        v1 = abs(edge_key[1])
        return (self.__getitem__(v0), self.__getitem__(v1))

    def get_vertex_obj(self, vid):
        return self.vertices[vid]

    def get_vertex_obj_from_pathway(self, pw):
        if pw in self.pathways:
            vid = self.pathways[pw]
            return self.vertices[vid]
        else:
            return None

    def get_pathway_from_vertex_id(self, vid):
        return self.__getitem__(vid)

    def network_dataframe(self, drop_weights_below=0, whitelist=None):
        """ Conversion of the network to a pandas dataframe. This allows for
            easy export to a CSV and visualization in Cytoscape.
        :param drop_weights_below: specify an edge weight threshold by which to
               filter our network.
        :param whitelist: list of edges to keep in the network (this is used
               during the permutation analysis).
        :returns: a pandas dataframe containing the network edge information.
             columns = [PW1, PW2, weight, nodes, type]
        """
        network_df = pd.DataFrame(columns=["PW1", "PW2",
                                           "Weight", "Nodes", "Type"])
        idx = 0
        for (v0, v1), edge_obj in self.edges.iteritems():
            if (edge_obj.weight > drop_weights_below and
                    (whitelist is None or (v0, v1) in whitelist)):
                nodes = edge_obj.adage_nodes_to_string()
                network_df.loc[idx] = [self.__getitem__(abs(v0)),
                                       self.__getitem__(abs(v1)),
                                       edge_obj.weight,
                                       nodes,
                                       edge_obj.etype]
                idx += 1  # faster to append by index.
        network_df = network_df.sort_values(by=["Type", "Weight"],
                                            ascending=False)
        print "This network contains " + str(self.num_pathways) + " pathways."
        return network_df

    def pathway_relations_count(self, pathway):
        """
        :param pathway: (str) pathway name
        :returns: (dict) for each etype, compute the # of nodes in which the
                  the pathway is involved
        """
        return self._pathway_relations_count_by_id(self.pathways[pathway])

    def pathway_neighbors_rel_count(self, pathway):
        """
        :param pathway: (str) pathway name
        :returns: { etype (key) -> dict (value) }
                  dict contains relation count information for all the first
                  neighbors of a given pathway
        """
        return self._pathway_neighbors_rel_count_by_id(self.pathways[pathway])

    def node_counts_excluding_edge(self, pw0, pw1, etype):
        """ Function used to collect counts for a hypergeometric test
        :param pw0: (str) pathway 0 of interest
        :param pw1: (str) pathway 1 of interest
        :param etype: (int) the edge type of interest
        :returns: (int) # of -etype- edges in the network excluding those
                  connected to the two pathways of interest.
        """
        vobj0 = self.get_vertex_obj_from_pathway(pw0)
        vobj1 = self.get_vertex_obj_from_pathway(pw1)
        vobj0_relations = self._pathway_relations_by_id_and_type(vobj0, etype)
        vobj1_relations = self._pathway_relations_by_id_and_type(vobj1, etype)
        exclude = self.nodes[etype] - (vobj0_relations | vobj1_relations)
        return len(exclude)

    def _add_edge_to_vertex(self, vid, edge):
        conn_to = edge.connected_to(vid)
        if vid not in self.vertices:
            vert_obj = Vertex(vid)
            vert_obj.edges[edge.etype][conn_to] = edge.weight
            self.vertices[vid] = vert_obj
        else:
            self.vertices[vid].edges[edge.etype][conn_to] = edge.weight

    def _augment_network(self, edge_dict, etype):
        for (s, e), node_list in edge_dict.iteritems():
            edge_obj = Edge(s, e, etype, node_list)
            self.edges[(s * etype, e * etype)] = edge_obj
            self._add_edge_to_vertex(s, edge_obj)
            self._add_edge_to_vertex(e, edge_obj)

    def _pathway_relations_count_by_id(self, vid):
        """
        :param vid: (int) vertex id
        :returns: { etype -> count }, where count is the # of -etype- edges
                  which contain the pathway with vertex id -vid-
        """
        vertex = self.vertices[vid]
        rel_counts = {}
        for etype in vertex.edges.keys():
            rel_counts[etype] = self._pathway_relations_count_by_id_and_type(
                vertex, etype)
        return rel_counts

    def _pathway_relations_count_by_id_and_type(self, vertex_obj, etype):
        return len(self._pathway_relations_by_id_and_type(vertex_obj, etype))

    def _pathway_relations_by_id_and_type(self, vertex_obj, etype):
        """ # of nodes in which a pathway show up with x type of relation.
            Get all of the first neighbors with that type. Add the nodes
            for which the relation appears between pw-neighbor to a set.
        """
        vneighbors = vertex_obj.first_neighbor_ids_by_type(etype)
        nodes = []
        for conn_to in vneighbors:
            eid = self.edge_tuple(vertex_obj.id, conn_to)
            if (etype == INV):
                eid = (-eid[0], -eid[1])
            nodes += self.edges[eid].get_adage_nodes()
        return set(nodes)

    def _pathway_neighbors_rel_count_by_id(self, vid):
        """ For each edge type, get the 1st neighbors of -vid-.
            For each 1st neighbor, determine the # of nodes where it has that
            edge type.
        :param vid: (int) vertex id
        :returns: { etype -> { neighbor -> count } }
        """
        vertex = self.vertices[vid]
        count_dicts = {}
        for etype in vertex.edges.keys():
            count_dicts[etype] = {}
            neighbors = vertex.first_neighbor_ids_by_type(etype)
            for conn_to in neighbors:
                pathway_name = self.__getitem__(conn_to)
                pathway_count = self._pathway_relations_count_by_id_and_type(
                    self.vertices[conn_to], etype)
                count_dicts[etype][pathway_name] = pathway_count
        return count_dicts

    def _total_edge_type_weight(self):
        """ Iterate over all edges in the network. Add the edge's weight
            to the corresponding edge type category.
        :returns: dictionary from etype -> total weight
        """
        totals = {}
        for edge_obj in self.edges.values():
            if edge_obj.etype not in totals:
                totals[edge_obj.etype] = 0
            totals[edge_obj.etype] += edge_obj.weight
            self.etype_weights = totals

    def _update_network_edge_info(self, to_update, weight, nodes, etype):
        to_update.append(weight)
        to_update.append(nodes)
        to_update.append(etype)
        return to_update

    ################################################################
    # ADAGE MODEL PERMUTATION: RELATED HELPER FUNCTIONS.
    ################################################################

    def _unzip(self, tuple_list):
        return [list(t) for t in zip(*tuple_list)]

    def _pathway_node_shuffle(self, pathway_node_tuples):
        """ Shuffle the pathways across nodes of one side in the network.
        :param pathway_node_tuples: [(pw, node)] list from the significant
               pathways in the ADAGE model.
        :returns: [(pw, node)] permuted list
        """
        pathways, nodes = self._unzip(pathway_node_tuples)
        random.shuffle(pathways)

        original_pws = pathways[:]
        node_locs = {}
        i = 0
        while i < len(pathways):
            starting_index = i
            current_node = nodes[i]
            pw_set = set()
            while i < len(pathways) and nodes[i] == current_node:
                if pathways[i] not in pw_set:
                    pw_set.add(pathways[i])
                else:
                    k = 0
                    while True:
                        j = random.choice(range(0, len(pathways)))
                        rpathway = pathways[j]
                        rnode = nodes[j]
                        if rpathway != pathways[i] and rpathway not in pw_set:
                            if rnode not in node_locs:
                                break
                            check = node_locs[rnode]
                            if pathways[i] not in pathways[check[0]:check[1]]:
                                break
                        k += 1
                        if k > MAX_ITERS:
                            print "Reached maximum number of iterations."
                            return None
                    pw_set.add(rpathway)
                    pathways[j] = pathways[i]
                    pathways[i] = rpathway
                i += 1
            ending_index = i
            node_locs[current_node] = (starting_index, ending_index)

        if original_pws == pathways:
            print "Pathway comparison: shuffle failed."
            return None

        return zip(pathways, nodes)

    def _shuffle_correctness(self, pathway_node_tuples, original):
        if pathway_node_tuples == original:
            return False
        node_pw_dict = {}
        for (pw, node) in pathway_node_tuples:
            if node not in node_pw_dict:
                node_pw_dict[node] = set()
            if pw in node_pw_dict[node]:
                print "Duplicate detected."
                return False
            else:
                node_pw_dict[node].add(pw)
        return True

    def _create_direct_edges_p(self, node_pw_dict):
        network_dict_direct = {}
        for node, pw_list in node_pw_dict.iteritems():
            for i in xrange(len(pw_list)):
                for j in range(i+1, len(pw_list)):
                    vi = pw_list[i]
                    vj = pw_list[j]
                    new_edge = self.edge_tuple(vi, vj)
                    if new_edge not in network_dict_direct:
                        network_dict_direct[new_edge] = []
                    network_dict_direct[new_edge].append(node)
        self._augment_network(network_dict_direct, DIR)

    def _create_inverse_edges_p(self, pos_node_dict, neg_node_dict):
        network_dict_inverse = {}
        for node, pos_list in pos_node_dict.iteritems():
            if node in neg_node_dict:
                neg_list = neg_node_dict[node]
                for i in xrange(len(pos_list)):
                    for j in xrange(len(neg_list)):
                        vi = pos_list[i]
                        vj = neg_list[j]
                        new_edge = self.edge_tuple(vi, vj)
                        if new_edge not in network_dict_inverse:
                            network_dict_inverse[new_edge] = []
                        network_dict_inverse[new_edge].append(node)
        self._augment_network(network_dict_inverse, INV)

    def _collect_pathways_by_node(self, pw_node_tuples):
        node_pw_dict = {}
        for (pw, node) in pw_node_tuples:
            v0 = self.add_pathway(pw)
            if node not in node_pw_dict:
                node_pw_dict[node] = []
            node_pw_dict[node].append(v0)
        return node_pw_dict

    def _construct_from_permutation(self, sig_pathways):
        """ Takes in a dictionary of "pos" and "neg" tuple lists containing
            the pathway-node mappings of a permuted ADAGE model.
        """
        # add all pathways:
        pos_tups = sig_pathways["pos"]
        neg_tups = sig_pathways["neg"]

        pos_dict = self._collect_pathways_by_node(pos_tups)
        neg_dict = self._collect_pathways_by_node(neg_tups)

        self._create_direct_edges_p(pos_dict)
        self._create_direct_edges_p(neg_dict)

        self._create_inverse_edges_p(pos_dict, neg_dict)

if __name__ == "__main__":
    test_network_file = sys.argv[1]
    num_nodes = sys.argv[2]
    output_file = sys.argv[3]
    # edits for cor_thresh
    cor_file = sys.argv[4]
    output_prefix = sys.argv[5]

    test_network = InteractionNetwork(test_network_file, num_nodes)
    shuffled = test_network.adage_model_permutation()
    test_df = test_network.network_dataframe()
    test_df.to_csv(path_or_buf=output_file,
                   sep="\t",
                   index=False)
    # edits for cor_thresh
    test_network._cor_score_filter(cor_file, output_prefix + "_inverse_")
    test_network._cor_score_filter(cor_file, output_prefix + "_direct_", True)
